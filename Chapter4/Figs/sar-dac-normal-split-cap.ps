%!PS-Adobe-3.0 EPSF-3.0
%%Title: sar-dac-normal-split-cap.ps
%%Creator: XCircuit v3.8 rev78
%%CreationDate: Fri May  4 15:30:05 2018
%%Pages: 1
%%BoundingBox: 68 68 592 252
%%DocumentNeededResources: font Helvetica Times-Roman 
%%EndComments
%%BeginProlog
%
%  PostScript prolog for output from xcircuit
%  Version: 3.8
%
%  Electrical circuit (and otherwise general) drawing program
%
%  Written by Tim Edwards 8/5/93--11/1/10  (tim.edwards@multigig.com)
%  The Johns Hopkins University (1993-2004)
%  MultiGiG, Inc. (2004-2012)
%
%%BeginResource: procset XCIRCproc 3.8 0
%
% supporting definitions --- these are the primary xcircuit types.

/XCIRCsave save def
/topmat matrix currentmatrix def

/fontslant { /slant exch def [1 0 slant 1 0 0] 
    exch findfont exch makefont dup length dict /ndict exch def
    { 1 index /FID ne { ndict 3 1 roll put } { pop pop } ifelse } forall
    ndict definefont pop} def
/ul { dup type /stringtype eq showflag 1 eq and { gsave 
   currentpoint topmat setmatrix 0 0 moveto 2 index stringwidth pop (_)
   false charpath flattenpath pathbbox grestore exch pop 1 index
   sub setlinewidth exch pop currentpoint 3 -1 roll add moveto 0
   rlineto stroke moveto } if } def
/ol { dup type /stringtype eq showflag 1 eq and { gsave gsave
   currentpoint topmat setmatrix 2 index stringwidth pop 3 index
   true charpath flattenpath pathbbox grestore exch pop
   exch pop topmat setmatrix (_) true charpath pathbbox grestore
   exch pop 1 index sub setlinewidth exch pop currentpoint
   exch 4 1 roll exch sub add moveto pop 0 rlineto stroke
   moveto } if } def
/stW { gsave currentpoint newpath moveto true charpath flattenpath
	pathbbox pop exch pop sub grestore } def
/Ts {mark Tabs aload pop counttomark 1 add array astore /Tabs exch def Tabs
	0 currentpoint pop put} def
/Tbn {mark Tabs aload pop counttomark dup 2 add 1 roll cleartomark 1 sub} def
/Tb { 0 1 Tbn {Tabs exch get dup currentpoint pop lt
	{currentpoint exch pop moveto exit} {pop} ifelse } for } def
/Tf { Tbn -1 0 {Tabs exch get dup currentpoint pop gt
	{currentpoint exch pop moveto exit} {pop} ifelse } for } def
/qS { (aa) stW (a a) stW sub 4 div 0 Kn } def
/hS { qS qS } def
/pspc 0 def
/cf0 { scalefont setfont } bind def
/Kn { dup kY add /kY exch def rmoveto } bind def
/ss { /fscale fscale 0.67 mul def currentfont 0.67 cf0 0 fscale0 fscale mul
	0.33 mul neg Kn} def
/Ss { /fscale fscale 0.67 mul def currentfont 0.67 cf0 0 fscale0 fscale mul
	0.67 mul Kn } def
/ns { 0 kY neg Kn /kY 0 def /fscale 1.0 def xfont0 1.0 cf0 } def
/MR { /twidth exch def } def
/CR { ns 0 /Bline Bline fscale0 neg add def Bline moveto } def
/cf { dup type /realtype ne {1.0} if exch findfont exch kY 0 eq
	{ 40 mul dup /fscale0 exch def cf0 /xfont0 currentfont def}
	{fscale0 mul fscale mul cf0} ifelse } def
/ctmk { counttomark dup 2 add -1 roll pop } bind def
/label { gsave translate 0 0 moveto dup scale neg
	/rotval exch def /twidth 100000 def /just exch def just 384 and
	0 gt {/mshow {pop} def} {/mshow {show} def} ifelse just 16 and 0
	gt {gsave rotval rotate 0 1 dtransform gsave pagemat setmatrix
	idtransform exch grestore 1 0 dtransform gsave pagemat setmatrix
	idtransform exch grestore dup abs 1e-9 lt {pop mul 0 gt} {3 1 roll
	pop pop 0 lt} ifelse grestore {-1 /rotval rotval neg def /just just
	dup 3 and 1 ne {3 xor} if def} {1} ifelse exch -1e-9 lt {-1 /rotval
	rotval neg def /just just dup 12 and 4 ne {12 xor} if def} {1}
	ifelse scale } if /showflag 0 def /fspc pspc def /Bline 0 def /Tabs
	0 array def /fscale 1.0 def /kY 0 def gsave dup 1 add copy dup
	1 0 dtransform exch atan rotate {exch dup type /stringtype eq {gsave
        dup gsave newpath 0 0 moveto true charpath flattenpath pathbbox pop
	exch pop exch pop grestore currentpoint pop add twidth
	ge {grestore CR exch 1 add dup 2 add {CR} exch 1 roll exch} {grestore}
	ifelse true charpath flattenpath} {dup type /arraytype eq {exec} {12
	string cvs true charpath flattenpath} ifelse} ifelse} repeat exch pop
	pathbbox grestore 3 -1 roll pop 3 1 roll just 1 and 0 gt {just 2 and
	0 gt {exch pop neg fspc sub} {exch sub 0.5 mul neg} ifelse} {pop neg
	fspc add} ifelse exch Bline exch just 4 and 0 gt {just 8 and 0 gt
	{exch pop neg fspc sub} {add 0.5 mul neg} ifelse} {pop neg fspc add}
	ifelse rotval rotate Kn currentpoint translate /showflag 1 def /Bline
	0 def /Tabs 0 array def /fscale 1.0 def /kY 0 def {dup type
	/stringtype eq {mshow} {dup type /arraytype eq {exec} {12 string cvs
	mshow} ifelse} ifelse} repeat grestore endclip} def
/pinlabel { 4 index 32 and 0 ne hlevel 0 eq or { /pspc 10 def label
	/pspc 0 def } { pop pop pop pop pop {pop} repeat } ifelse } def
/pinglobal { pinlabel } def
/infolabel { pinlabel } def
/graphic { gsave 4 index cvx exec /DataSource get resetfile translate 0 0
	moveto neg rotate dup scale cvx exec image grestore endclip} def

/scb { setrgbcolor } bind def  /sce { defColor aload pop scb } bind def
/cRedef {/defColor currentcolor 3 array astore def} def
/begingate {dup type /dicttype ne {1 dict} if begin	% default params
	dup type /dicttype ne {1 dict} if begin		% instanced params
	/hlevel hlevel 1 add def /defColor currentcolor sce 3 array astore
	def gsave sce translate 0 0 moveto neg rotate dup type /nametype
	eq not { dup abs currentlinewidth exch div setlinewidth } { pop }
	ifelse dup abs scale clipped 1 and 1 eq {/clipped clipped 1 add def}
	if} bind def
/endgate { /hlevel hlevel 1 sub def grestore defColor aload pop cRedef
	scb end end endclip} bind def

/hlevel 0 def
/endclip {clipped 1 and 1 eq {grestore /clipped clipped 1 sub def} if} def
/tmpa [1 0 0 1 0 0] def
/gar {8 8 true tmpa {<c0 c0 00 00 0c 0c 00 00>} imagemask} bind
{8 8 true tmpa {<30 70 60 02 03 07 06 20>} imagemask} bind
{8 8 true tmpa {<0c 1e 1e 0c c0 e1 e1 c0>} imagemask} bind
{8 8 true tmpa {<0f 0f 0f 0f f0 f0 f0 f0>} imagemask} bind
{8 8 true tmpa {<3f f3 e1 e1 f3 3f 1e 1e>} imagemask} bind
{8 8 true tmpa {<df cf 8f 9f fd fc f8 f9>} imagemask} bind
{8 8 true tmpa {<ff 3f 3f ff ff f3 f3 ff>} imagemask} bind 7 array astore def
/ppaint { gsave clip tmpa dup setmatrix pathbbox neg exch neg 4 2 roll
  neg 4 -1 roll 2 copy gt {exch} if 8 div ceiling 8 mul 4 2 roll neg 2 copy
  gt {exch} if 8 div ceiling 8 mul 3 -1 roll -8 5 -1 roll
  { 3 index exch 5 exch put dup -8 3 index { 3 index
  exch 4 exch put 3 index exec } for } for pop pop pop pop grestore } bind def
/setstyles {
  currentlinewidth mul setlinewidth /style exch def style 2048 and 0 gt
  clipped 1 and 0 eq and {clip newpath /clipped clipped 1 add def} {
  style 1 and 0 gt not {closepath} if
  style 1024 and 0 gt {2 setlinecap 0 setlinejoin} if
  style 2 and 0 gt {currentlinewidth 4 mul dup 2 array astore 0 setdash} if
  style 4 and 0 gt {0.5 currentlinewidth 4 mul 2 array astore 0 setdash} if
  gsave style 16 and 0 gt { style 224 and -5 bitshift style 256 and 0 gt {
  7 exch sub 8 div dup 1 exch sub currentrgbcolor 3 array astore
  {3 copy mul add 4 1 roll pop} forall pop pop setrgbcolor eofill}
  {dup 7 lt {gar exch get ppaint} {pop eofill} ifelse} ifelse}
  {style 256 and 0 gt {1 setgray eofill} if} ifelse grestore style 8 and 0 gt 
  style 512 eq or {newpath} {stroke} ifelse grestore endclip} ifelse} def     

/addtoy {exch dup dup 2 mul 3 add 1 roll -1 1 { 4 1 roll dup 4 1 roll add
	4 -1 roll 2 mul 1 add index 2 mul 2 add 2 roll} for pop} def
/addtoy1 {1 exch addtoy pop} def
/addtoy3 {3 exch addtoy pop} def
/addtoy4 {4 exch addtoy pop} def
/addtox {exch dup dup 2 mul 3 add 1 roll -1 1 { 4 1 roll dup 4 1 roll 3 -1 roll
	add exch 4 -1 roll 2 mul 1 add index 2 mul 2 add 2 roll} for pop} def
/addtox1 {1 exch addtox pop} def
/addtox3 {3 exch addtox pop} def
/addtox4 {4 exch addtox pop} def
/polygon { gsave /num exch def moveto num 1 sub {lineto} repeat setstyles } def
/xcarc   { gsave newpath arc setstyles } def
/elb { matrix currentmatrix 7 -1 roll 7 -1 roll translate 5 1 roll 4 -1 roll
	3 index div 1 scale } def
/ele { 0 4 1 roll 0 4 1 roll } bind def
/ellipse { gsave elb newpath ele arc setmatrix setstyles } def
/pellip  { elb ele arc setmatrix } def
/nellip  { elb ele arcn setmatrix } def
/spline  { gsave moveto curveto setstyles } def
/polyc   { {lineto} repeat } bind def
/beginpath { gsave moveto } bind def
/endpath { setstyles } bind def
/bop	 { 1 setlinecap 2 setlinejoin 6 setmiterlimit 0 0 0 scb cRedef
	/clipped 0 def} def
/psinsertion {/PSobj save def /showpage {} def /setpagedevice {pop} def bop
	rotate translate dup scale} def
/end_insert {PSobj restore} def
/setpagemat {/pagemat matrix currentmatrix def} def
/inchscale  {setpagemat 0.375 mul dup scale} def
/cmscale    {setpagemat 0.35433071 mul dup scale} def

%%EndResource
%%EndProlog

% XCircuit output starts here.

%%BeginSetup

/analog::gnd {
% trivial
begingate
1 2.000 0 0 0 -32 2 polygon
1 2.000 -32 -32 32 -32 2 polygon
1 2.000 -18 -46 18 -46 2 polygon
1 2.000 -4 -60 4 -60 2 polygon
0.933 0.604 0.000 scb
(GND) {/Times-Roman cf} 2 1 0 1.000 0 0 pinglobal
endgate
} def

/analog::capacitor {
begingate
1 2.000 0 64 0 6 2 polygon
1 2.000 -32 6 32 6 2 polygon
1.000 0.000 0.000 scb
(c.1) {/Times-Roman cf} 2 9 0 1.000 0 64 pinlabel
(c.2) {/Times-Roman cf} 2 13 0 1.000 0 -64 pinlabel
0.180 0.545 0.341 scb
(spice:C%i %pc.1 %pc.2 1.0P) {/Times-Roman cf} 2 0 0 1.000 -208 -160 infolabel
(sim:c %pc.1 %pc.2) {/Times-Roman cf} 2 0 0 1.000 -208 -208 infolabel
sce
0 2.000 -32 -8 -32 0 32 0 32 -8 4 polygon
1 2.000 0 -64 0 -8 2 polygon
endgate
} def

/generic::arrowhead {
% nonetwork
begingate
8 -28 beginpath
3 -18 3 -15 0 0 curveto
-3 -15 -3 -18 -8 -28 curveto
-2 -26 2 -26 8 -28 curveto
249 
1.000 endpath
endgate
} def


%%EndSetup

%%Page: XC4583.Y6j1jV 1
%%PageOrientation: Portrait
/pgsave save def bop
% 32.00 4.00 gridspace
1.0000 inchscale
2.6000 setlinewidth 644 228 translate

0.500 0 -420 20 analog::gnd
1.000 0 -420 84 analog::capacitor
(0) {ss} (b) {/Helvetica cf} 4 16 0 1.000 -308 -12 label
(1) {ss} (b) {/Helvetica cf} 4 16 0 1.000 -180 -12 label
(2) {ss} (b) {/Helvetica cf} 4 16 0 1.000 -52 -12 label
(3) {ss} (b) {/Helvetica cf} 4 16 0 1.000 76 -12 label
(4) {ss} (b) {/Helvetica cf} 4 16 0 1.000 204 -12 label
(5) {ss} (b) {/Helvetica cf} 4 16 0 1.000 332 -12 label
1.000 0 -292 84 analog::capacitor
1.000 0 -164 84 analog::capacitor
1.000 0 -36 84 analog::capacitor
1.000 0 92 84 analog::capacitor
1.000 0 220 84 analog::capacitor
1.000 0 348 84 analog::capacitor
1 2.000 348 148 412 148 2 polygon
1.000 90 436 148 generic::arrowhead
(r) {ss} (V) {/Helvetica cf} 4 16 0 1.000 452 140 label
(2) {/Helvetica cf} 2 16 0 0.750 -148 104 label
(4) {/Helvetica cf} 2 16 0 0.750 -20 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 -396 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 -268 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 -128 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 0 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 128 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 256 104 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 384 104 label
0.500 0 -416 288 analog::gnd
1.000 0 -416 352 analog::capacitor
(0) {ss} (b) {/Helvetica cf} 4 16 0 1.000 -304 256 label
(1) {ss} (b) {/Helvetica cf} 4 16 0 1.000 -176 256 label
(2) {ss} (b) {/Helvetica cf} 4 16 0 1.000 -48 256 label
(3) {ss} (b) {/Helvetica cf} 4 16 0 1.000 80 256 label
(4) {ss} (b) {/Helvetica cf} 4 16 0 1.000 208 256 label
(5) {ss} (b) {/Helvetica cf} 4 16 0 1.000 336 256 label
1.000 0 -288 352 analog::capacitor
1.000 0 -160 352 analog::capacitor
1.000 0 -32 352 analog::capacitor
1.000 0 96 352 analog::capacitor
1.000 0 224 352 analog::capacitor
1.000 0 352 352 analog::capacitor
1 2.000 -416 416 352 416 2 polygon
1 2.000 352 416 416 416 2 polygon
1.000 90 440 416 generic::arrowhead
(r) {ss} (V) {/Helvetica cf} 4 16 0 1.000 456 408 label
(2) {/Helvetica cf} 2 16 0 0.750 -144 372 label
(4) {/Helvetica cf} 2 16 0 0.750 -16 372 label
(8) {/Helvetica cf} 2 16 0 0.750 112 372 label
(16) {/Helvetica cf} 2 16 0 0.750 240 372 label
(32) {/Helvetica cf} 2 16 0 0.750 360 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 -392 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 -264 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 -124 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 4 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 132 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 268 372 label
(0) {ss} (C) {/Helvetica cf} 4 16 0 0.750 392 372 label
5 1.000 40 208 40 -36 2 polygon
1.000 0.000 0.000 scb
1 1.000 44 212 80 212 76 216 3 polygon
1 1.000 80 212 76 208 2 polygon
0.000 0.000 1.000 scb
1 1.000 44 212 8 212 12 216 3 polygon
1 1.000 8 212 12 208 2 polygon
1.000 0.000 0.000 scb
(MSB) {/Helvetica cf} 2 16 0 0.800 92 200 label
0.000 0.000 1.000 scb
(LSB) {/Helvetica cf} 2 16 0 0.800 -68 200 label
sce
(4) {/Helvetica cf} 2 16 0 0.750 364 104 label
(2) {/Helvetica cf} 2 16 0 0.750 236 104 label
0.750 90 40 148 analog::capacitor
1 2.000 88 148 348 148 2 polygon
1 2.000 -8 148 -420 148 2 polygon
1.000 0.000 0.000 scb
497 2.000 572 292 572 420 924 420 924 292 764 292 764 184 780 184 748 152 716 
184 732 184 732 292 572 292 12 polygon
0.180 0.545 0.341 scb
496 2.000 572 148 572 20 924 20 924 148 4 polygon
1.000 1.000 1.000 scb
(Load to be driven) {/Helvetica cf} 2 16 0 1.000 600 376 label
(0) {ss} (64 C) {/Helvetica cf} 4 16 0 1.000 696 328 label
(Load to be driven) {/Helvetica cf} 2 16 0 1.000 596 92 label
(0) {ss} (15 C) {/Helvetica cf} 4 16 0 1.000 704 48 label
sce
(a) {ss} (C) {/Helvetica cf} 4 16 0 1.000 48 164 label
pgsave restore showpage

%%Trailer
XCIRCsave restore
%%EOF
